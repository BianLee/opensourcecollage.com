{"ast":null,"code":"/**\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {Omit<import('parse5').Element, 'parentNode'>} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {Omit<import('parse5').Location, 'startOffset' | 'endOffset'> & {startOffset: number|undefined, endOffset: number|undefined}} P5Location\n * @typedef {import('parse5').ParserOptions} P5ParserOptions\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Literal} Literal\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {Literal & {type: 'raw'}} Raw\n * @typedef {Parent['children'][number]} Child\n * @typedef {Child|Root|Raw} Node\n * @typedef {import('vfile').VFile} VFile\n * @typedef {Literal & {type: 'comment', value: {stitch: UnistNode}}} Stitch\n *\n * @typedef Options\n * @property {Array.<string>} [passThrough] List of custom hast node types to pass through (keep) in hast. If the passed through nodes have children, those children are expected to be hast and will be handled\n *\n * @typedef HiddenTokenizer\n * @property {Array.<HiddenLocationTracker>} __mixins Way too simple, but works for us.\n * @property {HiddenPreprocessor} preprocessor\n * @property {(value: string) => void} write\n * @property {Array.<HiddenToken>} tokenQueue\n * @property {string} state\n * @property {string} returnState\n * @property {number} charRefCode\n * @property {Array.<number>} tempBuff\n * @property {string} lastStartTagName\n * @property {number} consumedAfterSnapshot\n * @property {boolean} active\n * @property {HiddenToken|undefined} currentCharacterToken\n * @property {HiddenToken|undefined} currentToken\n * @property {unknown} currentAttr\n *\n * @typedef {Object.<string, unknown> & {location: P5Location}} HiddenToken\n *\n * @typedef HiddenPreprocessor\n * @property {string|undefined} html\n * @property {number} pos\n * @property {number} lastGapPos\n * @property {number} lastCharPos\n * @property {Array.<number>} gapStack\n * @property {boolean} skipNextNewLine\n * @property {boolean} lastChunkWritten\n * @property {boolean} endOfChunkHit\n *\n * @typedef HiddenLocationTracker\n * @property {P5Location|undefined} currentAttrLocation\n * @property {P5Location} ctLoc\n * @property {HiddenPosTracker} posTracker\n *\n * @typedef HiddenPosTracker\n * @property {boolean} isEol\n * @property {number} lineStartPos\n * @property {number} droppedBufferSize\n * @property {number} offset\n * @property {number} col\n * @property {number} line\n */\n// @ts-expect-error: untyped.\nimport Parser from 'parse5/lib/parser/index.js';\nimport { pointStart, pointEnd } from 'unist-util-position';\nimport { visit } from 'unist-util-visit';\nimport { fromParse5 } from 'hast-util-from-parse5';\nimport { toParse5 } from 'hast-util-to-parse5';\nimport { htmlVoidElements } from 'html-void-elements';\nimport { webNamespaces } from 'web-namespaces';\nimport { zwitch } from 'zwitch';\nconst inTemplateMode = 'IN_TEMPLATE_MODE';\nconst dataState = 'DATA_STATE';\nconst characterToken = 'CHARACTER_TOKEN';\nconst startTagToken = 'START_TAG_TOKEN';\nconst endTagToken = 'END_TAG_TOKEN';\nconst commentToken = 'COMMENT_TOKEN';\nconst doctypeToken = 'DOCTYPE_TOKEN';\n/** @type {P5ParserOptions} */\n\nconst parseOptions = {\n  sourceCodeLocationInfo: true,\n  scriptingEnabled: false\n};\n/**\n * Given a hast tree and an optional vfile (for positional info), return a new\n * parsed-again hast tree.\n *\n * @param {Node} tree Original hast tree\n * @param {VFile} [file] Virtual file for positional info\n * @param {Options} [options] Configuration\n */\n\nexport function raw(tree, file, options) {\n  let index = -1;\n  const parser = new Parser(parseOptions);\n  const one = zwitch('type', {\n    // @ts-expect-error: hush.\n    handlers: {\n      root,\n      element,\n      text,\n      comment,\n      doctype,\n      raw: handleRaw\n    },\n    // @ts-expect-error: hush.\n    unknown\n  });\n  /** @type {boolean|undefined} */\n\n  let stitches;\n  /** @type {HiddenTokenizer|undefined} */\n\n  let tokenizer;\n  /** @type {HiddenPreprocessor|undefined} */\n\n  let preprocessor;\n  /** @type {HiddenPosTracker|undefined} */\n\n  let posTracker;\n  /** @type {HiddenLocationTracker|undefined} */\n\n  let locationTracker;\n\n  if (isOptions(file)) {\n    options = file;\n    file = undefined;\n  }\n\n  if (options && options.passThrough) {\n    while (++index < options.passThrough.length) {\n      // @ts-expect-error: hush.\n      one.handlers[options.passThrough[index]] = stitch;\n    }\n  }\n\n  const result = fromParse5(documentMode(tree) ? document() : fragment(), file);\n\n  if (stitches) {\n    visit(result, 'comment', (node, index, parent) => {\n      const stitch =\n      /** @type {Stitch} */\n      node;\n\n      if (stitch.value.stitch && parent !== null && index !== null) {\n        parent.children[index] = stitch.value.stitch;\n        return index;\n      }\n    });\n  } // Unpack if possible and when not given a `root`.\n\n\n  if (tree.type !== 'root' && result.type === 'root' && result.children.length === 1) {\n    return result.children[0];\n  }\n\n  return result;\n  /**\n   * @returns {P5Fragment}\n   */\n\n  function fragment() {\n    /** @type {P5Element} */\n    const context = {\n      nodeName: 'template',\n      tagName: 'template',\n      attrs: [],\n      namespaceURI: webNamespaces.html,\n      childNodes: []\n    };\n    /** @type {P5Element} */\n\n    const mock = {\n      nodeName: 'documentmock',\n      tagName: 'documentmock',\n      attrs: [],\n      namespaceURI: webNamespaces.html,\n      childNodes: []\n    };\n    /** @type {P5Fragment} */\n\n    const doc = {\n      nodeName: '#document-fragment',\n      childNodes: []\n    };\n\n    parser._bootstrap(mock, context);\n\n    parser._pushTmplInsertionMode(inTemplateMode);\n\n    parser._initTokenizerForFragmentParsing();\n\n    parser._insertFakeRootElement();\n\n    parser._resetInsertionMode();\n\n    parser._findFormInFragmentContext();\n\n    tokenizer = parser.tokenizer;\n    /* c8 ignore next */\n\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    preprocessor = tokenizer.preprocessor;\n    locationTracker = tokenizer.__mixins[0];\n    posTracker = locationTracker.posTracker;\n    one(tree);\n\n    parser._adoptNodes(mock.childNodes[0], doc);\n\n    return doc;\n  }\n  /**\n   * @returns {P5Document}\n   */\n\n\n  function document() {\n    /** @type {P5Document} */\n    const doc = parser.treeAdapter.createDocument();\n\n    parser._bootstrap(doc, undefined);\n\n    tokenizer = parser.tokenizer;\n    /* c8 ignore next */\n\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    preprocessor = tokenizer.preprocessor;\n    locationTracker = tokenizer.__mixins[0];\n    posTracker = locationTracker.posTracker;\n    one(tree);\n    return doc;\n  }\n  /**\n   * @param {Array.<Child>} nodes\n   * @returns {void}\n   */\n\n\n  function all(nodes) {\n    let index = -1;\n    /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n\n    if (nodes) {\n      while (++index < nodes.length) {\n        one(nodes[index]);\n      }\n    }\n  }\n  /**\n   * @param {Root} node\n   * @returns {void}\n   */\n\n\n  function root(node) {\n    all(node.children);\n  }\n  /**\n   * @param {Element} node\n   * @returns {void}\n   */\n\n\n  function element(node) {\n    resetTokenizer();\n\n    parser._processToken(startTag(node), webNamespaces.html);\n\n    all(node.children);\n\n    if (!htmlVoidElements.includes(node.tagName)) {\n      resetTokenizer();\n\n      parser._processToken(endTag(node));\n    }\n  }\n  /**\n   * @param {Text} node\n   * @returns {void}\n   */\n\n\n  function text(node) {\n    resetTokenizer();\n\n    parser._processToken({\n      type: characterToken,\n      chars: node.value,\n      location: createParse5Location(node)\n    });\n  }\n  /**\n   * @param {Doctype} node\n   * @returns {void}\n   */\n\n\n  function doctype(node) {\n    resetTokenizer();\n\n    parser._processToken({\n      type: doctypeToken,\n      name: 'html',\n      forceQuirks: false,\n      publicId: '',\n      systemId: '',\n      location: createParse5Location(node)\n    });\n  }\n  /**\n   * @param {Comment|Stitch} node\n   * @returns {void}\n   */\n\n\n  function comment(node) {\n    resetTokenizer();\n\n    parser._processToken({\n      type: commentToken,\n      data: node.value,\n      location: createParse5Location(node)\n    });\n  }\n  /**\n   * @param {Raw} node\n   * @returns {void}\n   */\n\n\n  function handleRaw(node) {\n    const start = pointStart(node);\n    const line = start.line || 1;\n    const column = start.column || 1;\n    const offset = start.offset || 0;\n    /* c8 ignore next 4 */\n\n    if (!preprocessor) throw new Error('Expected `preprocessor`');\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    if (!posTracker) throw new Error('Expected `posTracker`');\n    if (!locationTracker) throw new Error('Expected `locationTracker`'); // Reset preprocessor:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js>.\n\n    preprocessor.html = undefined;\n    preprocessor.pos = -1;\n    preprocessor.lastGapPos = -1;\n    preprocessor.lastCharPos = -1;\n    preprocessor.gapStack = [];\n    preprocessor.skipNextNewLine = false;\n    preprocessor.lastChunkWritten = false;\n    preprocessor.endOfChunkHit = false; // Reset preprocessor mixin:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n\n    posTracker.isEol = false;\n    posTracker.lineStartPos = -column + 1; // Looks weird, but ensures we get correct positional info.\n\n    posTracker.droppedBufferSize = offset;\n    posTracker.offset = 0;\n    posTracker.col = 1;\n    posTracker.line = line; // Reset location tracker:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n\n    locationTracker.currentAttrLocation = undefined;\n    locationTracker.ctLoc = createParse5Location(node); // See the code for `parse` and `parseFragment`:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n\n    tokenizer.write(node.value);\n\n    parser._runParsingLoop(undefined); // Process final characters if they’re still there after hibernating.\n    // Similar to:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n\n\n    const token = tokenizer.currentCharacterToken;\n\n    if (token) {\n      token.location.endLine = posTracker.line;\n      token.location.endCol = posTracker.col + 1;\n      token.location.endOffset = posTracker.offset + 1;\n\n      parser._processToken(token);\n    }\n  }\n  /**\n   * @param {UnistNode} node\n   */\n\n\n  function stitch(node) {\n    const clone = Object.assign({}, node);\n    stitches = true; // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n    // passed through node).\n\n    if ('children' in node) {\n      // @ts-expect-error Assume parent.\n      clone.children = raw( // @ts-expect-error Assume parent.\n      {\n        type: 'root',\n        children: node.children\n      }, file, options // @ts-expect-error Assume parent.\n      ).children;\n    } // Hack: `value` is supposed to be a string, but as none of the tools\n    // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n    // through.\n    // @ts-expect-error\n\n\n    comment({\n      value: {\n        stitch: clone\n      }\n    });\n  }\n\n  function resetTokenizer() {\n    /* c8 ignore next */\n    if (!tokenizer) throw new Error('Expected `tokenizer`'); // Reset tokenizer:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n    // Especially putting it back in the `data` state is useful: some elements,\n    // like textareas and iframes, change the state.\n    // See GH-7.\n    // But also if broken HTML is in `raw`, and then a correct element is given.\n    // See GH-11.\n\n    tokenizer.tokenQueue = [];\n    tokenizer.state = dataState;\n    tokenizer.returnState = '';\n    tokenizer.charRefCode = -1;\n    tokenizer.tempBuff = [];\n    tokenizer.lastStartTagName = '';\n    tokenizer.consumedAfterSnapshot = -1;\n    tokenizer.active = false;\n    tokenizer.currentCharacterToken = undefined;\n    tokenizer.currentToken = undefined;\n    tokenizer.currentAttr = undefined;\n  }\n}\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\n\nfunction startTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node)); // @ts-expect-error extra positional info.\n\n  location.startTag = Object.assign({}, location); // Untyped token.\n\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location\n  };\n}\n/**\n * @param {Element} node\n * @returns {Array.<P5Attribute>}\n */\n\n\nfunction attributes(node) {\n  return toParse5({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties,\n    children: [] // @ts-expect-error Assume element.\n\n  }).attrs;\n}\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\n\n\nfunction endTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node)); // @ts-expect-error extra positional info.\n\n  location.startTag = Object.assign({}, location); // Untyped token.\n\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location\n  };\n}\n/**\n * @param {Node} node\n */\n\n\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node');\n}\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node;\n  return Boolean(head && (head.type === 'doctype' || head.type === 'element' && head.tagName === 'html'));\n}\n/**\n * @param {Node} node\n * @returns {P5Location}\n */\n\n\nfunction createParse5Location(node) {\n  const start = pointStart(node);\n  const end = pointEnd(node);\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  };\n}\n/**\n * @param {VFile|Options|undefined} value\n * @return {value is Options}\n */\n\n\nfunction isOptions(value) {\n  return Boolean(value && !('message' in value && 'messages' in value));\n}","map":{"version":3,"sources":["/home/bian/Desktop/Summer/a/node_modules/hast-util-raw/lib/index.js"],"names":["Parser","pointStart","pointEnd","visit","fromParse5","toParse5","htmlVoidElements","webNamespaces","zwitch","inTemplateMode","dataState","characterToken","startTagToken","endTagToken","commentToken","doctypeToken","parseOptions","sourceCodeLocationInfo","scriptingEnabled","raw","tree","file","options","index","parser","one","handlers","root","element","text","comment","doctype","handleRaw","unknown","stitches","tokenizer","preprocessor","posTracker","locationTracker","isOptions","undefined","passThrough","length","stitch","result","documentMode","document","fragment","node","parent","value","children","type","context","nodeName","tagName","attrs","namespaceURI","html","childNodes","mock","doc","_bootstrap","_pushTmplInsertionMode","_initTokenizerForFragmentParsing","_insertFakeRootElement","_resetInsertionMode","_findFormInFragmentContext","Error","__mixins","_adoptNodes","treeAdapter","createDocument","all","nodes","resetTokenizer","_processToken","startTag","includes","endTag","chars","location","createParse5Location","name","forceQuirks","publicId","systemId","data","start","line","column","offset","pos","lastGapPos","lastCharPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","isEol","lineStartPos","droppedBufferSize","col","currentAttrLocation","ctLoc","write","_runParsingLoop","token","currentCharacterToken","endLine","endCol","endOffset","clone","Object","assign","tokenQueue","state","returnState","charRefCode","tempBuff","lastStartTagName","consumedAfterSnapshot","active","currentToken","currentAttr","selfClosing","attributes","properties","head","Boolean","end","startLine","startCol","startOffset"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {Omit<import('parse5').Element, 'parentNode'>} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {Omit<import('parse5').Location, 'startOffset' | 'endOffset'> & {startOffset: number|undefined, endOffset: number|undefined}} P5Location\n * @typedef {import('parse5').ParserOptions} P5ParserOptions\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Literal} Literal\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {Literal & {type: 'raw'}} Raw\n * @typedef {Parent['children'][number]} Child\n * @typedef {Child|Root|Raw} Node\n * @typedef {import('vfile').VFile} VFile\n * @typedef {Literal & {type: 'comment', value: {stitch: UnistNode}}} Stitch\n *\n * @typedef Options\n * @property {Array.<string>} [passThrough] List of custom hast node types to pass through (keep) in hast. If the passed through nodes have children, those children are expected to be hast and will be handled\n *\n * @typedef HiddenTokenizer\n * @property {Array.<HiddenLocationTracker>} __mixins Way too simple, but works for us.\n * @property {HiddenPreprocessor} preprocessor\n * @property {(value: string) => void} write\n * @property {Array.<HiddenToken>} tokenQueue\n * @property {string} state\n * @property {string} returnState\n * @property {number} charRefCode\n * @property {Array.<number>} tempBuff\n * @property {string} lastStartTagName\n * @property {number} consumedAfterSnapshot\n * @property {boolean} active\n * @property {HiddenToken|undefined} currentCharacterToken\n * @property {HiddenToken|undefined} currentToken\n * @property {unknown} currentAttr\n *\n * @typedef {Object.<string, unknown> & {location: P5Location}} HiddenToken\n *\n * @typedef HiddenPreprocessor\n * @property {string|undefined} html\n * @property {number} pos\n * @property {number} lastGapPos\n * @property {number} lastCharPos\n * @property {Array.<number>} gapStack\n * @property {boolean} skipNextNewLine\n * @property {boolean} lastChunkWritten\n * @property {boolean} endOfChunkHit\n *\n * @typedef HiddenLocationTracker\n * @property {P5Location|undefined} currentAttrLocation\n * @property {P5Location} ctLoc\n * @property {HiddenPosTracker} posTracker\n *\n * @typedef HiddenPosTracker\n * @property {boolean} isEol\n * @property {number} lineStartPos\n * @property {number} droppedBufferSize\n * @property {number} offset\n * @property {number} col\n * @property {number} line\n */\n\n// @ts-expect-error: untyped.\nimport Parser from 'parse5/lib/parser/index.js'\nimport {pointStart, pointEnd} from 'unist-util-position'\nimport {visit} from 'unist-util-visit'\nimport {fromParse5} from 'hast-util-from-parse5'\nimport {toParse5} from 'hast-util-to-parse5'\nimport {htmlVoidElements} from 'html-void-elements'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\nconst inTemplateMode = 'IN_TEMPLATE_MODE'\nconst dataState = 'DATA_STATE'\nconst characterToken = 'CHARACTER_TOKEN'\nconst startTagToken = 'START_TAG_TOKEN'\nconst endTagToken = 'END_TAG_TOKEN'\nconst commentToken = 'COMMENT_TOKEN'\nconst doctypeToken = 'DOCTYPE_TOKEN'\n\n/** @type {P5ParserOptions} */\nconst parseOptions = {sourceCodeLocationInfo: true, scriptingEnabled: false}\n\n/**\n * Given a hast tree and an optional vfile (for positional info), return a new\n * parsed-again hast tree.\n *\n * @param {Node} tree Original hast tree\n * @param {VFile} [file] Virtual file for positional info\n * @param {Options} [options] Configuration\n */\nexport function raw(tree, file, options) {\n  let index = -1\n  const parser = new Parser(parseOptions)\n  const one = zwitch('type', {\n    // @ts-expect-error: hush.\n    handlers: {root, element, text, comment, doctype, raw: handleRaw},\n    // @ts-expect-error: hush.\n    unknown\n  })\n  /** @type {boolean|undefined} */\n  let stitches\n  /** @type {HiddenTokenizer|undefined} */\n  let tokenizer\n  /** @type {HiddenPreprocessor|undefined} */\n  let preprocessor\n  /** @type {HiddenPosTracker|undefined} */\n  let posTracker\n  /** @type {HiddenLocationTracker|undefined} */\n  let locationTracker\n\n  if (isOptions(file)) {\n    options = file\n    file = undefined\n  }\n\n  if (options && options.passThrough) {\n    while (++index < options.passThrough.length) {\n      // @ts-expect-error: hush.\n      one.handlers[options.passThrough[index]] = stitch\n    }\n  }\n\n  const result = fromParse5(documentMode(tree) ? document() : fragment(), file)\n\n  if (stitches) {\n    visit(result, 'comment', (node, index, parent) => {\n      const stitch = /** @type {Stitch} */ (node)\n      if (stitch.value.stitch && parent !== null && index !== null) {\n        parent.children[index] = stitch.value.stitch\n        return index\n      }\n    })\n  }\n\n  // Unpack if possible and when not given a `root`.\n  if (\n    tree.type !== 'root' &&\n    result.type === 'root' &&\n    result.children.length === 1\n  ) {\n    return result.children[0]\n  }\n\n  return result\n\n  /**\n   * @returns {P5Fragment}\n   */\n  function fragment() {\n    /** @type {P5Element} */\n    const context = {\n      nodeName: 'template',\n      tagName: 'template',\n      attrs: [],\n      namespaceURI: webNamespaces.html,\n      childNodes: []\n    }\n    /** @type {P5Element} */\n    const mock = {\n      nodeName: 'documentmock',\n      tagName: 'documentmock',\n      attrs: [],\n      namespaceURI: webNamespaces.html,\n      childNodes: []\n    }\n    /** @type {P5Fragment} */\n    const doc = {nodeName: '#document-fragment', childNodes: []}\n\n    parser._bootstrap(mock, context)\n    parser._pushTmplInsertionMode(inTemplateMode)\n    parser._initTokenizerForFragmentParsing()\n    parser._insertFakeRootElement()\n    parser._resetInsertionMode()\n    parser._findFormInFragmentContext()\n\n    tokenizer = parser.tokenizer\n    /* c8 ignore next */\n    if (!tokenizer) throw new Error('Expected `tokenizer`')\n    preprocessor = tokenizer.preprocessor\n    locationTracker = tokenizer.__mixins[0]\n    posTracker = locationTracker.posTracker\n\n    one(tree)\n\n    parser._adoptNodes(mock.childNodes[0], doc)\n\n    return doc\n  }\n\n  /**\n   * @returns {P5Document}\n   */\n  function document() {\n    /** @type {P5Document} */\n    const doc = parser.treeAdapter.createDocument()\n\n    parser._bootstrap(doc, undefined)\n    tokenizer = parser.tokenizer\n    /* c8 ignore next */\n    if (!tokenizer) throw new Error('Expected `tokenizer`')\n    preprocessor = tokenizer.preprocessor\n    locationTracker = tokenizer.__mixins[0]\n    posTracker = locationTracker.posTracker\n\n    one(tree)\n\n    return doc\n  }\n\n  /**\n   * @param {Array.<Child>} nodes\n   * @returns {void}\n   */\n  function all(nodes) {\n    let index = -1\n\n    /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n    if (nodes) {\n      while (++index < nodes.length) {\n        one(nodes[index])\n      }\n    }\n  }\n\n  /**\n   * @param {Root} node\n   * @returns {void}\n   */\n  function root(node) {\n    all(node.children)\n  }\n\n  /**\n   * @param {Element} node\n   * @returns {void}\n   */\n  function element(node) {\n    resetTokenizer()\n    parser._processToken(startTag(node), webNamespaces.html)\n\n    all(node.children)\n\n    if (!htmlVoidElements.includes(node.tagName)) {\n      resetTokenizer()\n      parser._processToken(endTag(node))\n    }\n  }\n\n  /**\n   * @param {Text} node\n   * @returns {void}\n   */\n  function text(node) {\n    resetTokenizer()\n    parser._processToken({\n      type: characterToken,\n      chars: node.value,\n      location: createParse5Location(node)\n    })\n  }\n\n  /**\n   * @param {Doctype} node\n   * @returns {void}\n   */\n  function doctype(node) {\n    resetTokenizer()\n    parser._processToken({\n      type: doctypeToken,\n      name: 'html',\n      forceQuirks: false,\n      publicId: '',\n      systemId: '',\n      location: createParse5Location(node)\n    })\n  }\n\n  /**\n   * @param {Comment|Stitch} node\n   * @returns {void}\n   */\n  function comment(node) {\n    resetTokenizer()\n    parser._processToken({\n      type: commentToken,\n      data: node.value,\n      location: createParse5Location(node)\n    })\n  }\n\n  /**\n   * @param {Raw} node\n   * @returns {void}\n   */\n  function handleRaw(node) {\n    const start = pointStart(node)\n    const line = start.line || 1\n    const column = start.column || 1\n    const offset = start.offset || 0\n\n    /* c8 ignore next 4 */\n    if (!preprocessor) throw new Error('Expected `preprocessor`')\n    if (!tokenizer) throw new Error('Expected `tokenizer`')\n    if (!posTracker) throw new Error('Expected `posTracker`')\n    if (!locationTracker) throw new Error('Expected `locationTracker`')\n\n    // Reset preprocessor:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js>.\n    preprocessor.html = undefined\n    preprocessor.pos = -1\n    preprocessor.lastGapPos = -1\n    preprocessor.lastCharPos = -1\n    preprocessor.gapStack = []\n    preprocessor.skipNextNewLine = false\n    preprocessor.lastChunkWritten = false\n    preprocessor.endOfChunkHit = false\n\n    // Reset preprocessor mixin:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n    posTracker.isEol = false\n    posTracker.lineStartPos = -column + 1 // Looks weird, but ensures we get correct positional info.\n    posTracker.droppedBufferSize = offset\n    posTracker.offset = 0\n    posTracker.col = 1\n    posTracker.line = line\n\n    // Reset location tracker:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n    locationTracker.currentAttrLocation = undefined\n    locationTracker.ctLoc = createParse5Location(node)\n\n    // See the code for `parse` and `parseFragment`:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n    tokenizer.write(node.value)\n    parser._runParsingLoop(undefined)\n\n    // Process final characters if they’re still there after hibernating.\n    // Similar to:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n    const token = tokenizer.currentCharacterToken\n\n    if (token) {\n      token.location.endLine = posTracker.line\n      token.location.endCol = posTracker.col + 1\n      token.location.endOffset = posTracker.offset + 1\n      parser._processToken(token)\n    }\n  }\n\n  /**\n   * @param {UnistNode} node\n   */\n  function stitch(node) {\n    const clone = Object.assign({}, node)\n\n    stitches = true\n\n    // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n    // passed through node).\n    if ('children' in node) {\n      // @ts-expect-error Assume parent.\n      clone.children = raw(\n        // @ts-expect-error Assume parent.\n        {type: 'root', children: node.children},\n        file,\n        options\n        // @ts-expect-error Assume parent.\n      ).children\n    }\n\n    // Hack: `value` is supposed to be a string, but as none of the tools\n    // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n    // through.\n    // @ts-expect-error\n    comment({value: {stitch: clone}})\n  }\n\n  function resetTokenizer() {\n    /* c8 ignore next */\n    if (!tokenizer) throw new Error('Expected `tokenizer`')\n\n    // Reset tokenizer:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n    // Especially putting it back in the `data` state is useful: some elements,\n    // like textareas and iframes, change the state.\n    // See GH-7.\n    // But also if broken HTML is in `raw`, and then a correct element is given.\n    // See GH-11.\n    tokenizer.tokenQueue = []\n    tokenizer.state = dataState\n    tokenizer.returnState = ''\n    tokenizer.charRefCode = -1\n    tokenizer.tempBuff = []\n    tokenizer.lastStartTagName = ''\n    tokenizer.consumedAfterSnapshot = -1\n    tokenizer.active = false\n    tokenizer.currentCharacterToken = undefined\n    tokenizer.currentToken = undefined\n    tokenizer.currentAttr = undefined\n  }\n}\n\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction startTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location\n  }\n}\n\n/**\n * @param {Element} node\n * @returns {Array.<P5Attribute>}\n */\nfunction attributes(node) {\n  return toParse5({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties,\n    children: []\n    // @ts-expect-error Assume element.\n  }).attrs\n}\n\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction endTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location\n  }\n}\n\n/**\n * @param {Node} node\n */\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node')\n}\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node\n  return Boolean(\n    head &&\n      (head.type === 'doctype' ||\n        (head.type === 'element' && head.tagName === 'html'))\n  )\n}\n\n/**\n * @param {Node} node\n * @returns {P5Location}\n */\nfunction createParse5Location(node) {\n  const start = pointStart(node)\n  const end = pointEnd(node)\n\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  }\n}\n\n/**\n * @param {VFile|Options|undefined} value\n * @return {value is Options}\n */\nfunction isOptions(value) {\n  return Boolean(value && !('message' in value && 'messages' in value))\n}\n"]},"metadata":{},"sourceType":"module"}