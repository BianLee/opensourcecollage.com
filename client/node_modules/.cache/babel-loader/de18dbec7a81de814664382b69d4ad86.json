{"ast":null,"code":"/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('unist-util-is').AssertPredicate<Element>} AssertElement\n * @typedef {import('unist-util-is').AssertPredicate<Text>} AssertText\n * @typedef {import('unist-util-is').AssertPredicate<Root>} AssertRoot\n *\n * @callback CreateElementLike\n * @param {string} name\n * @param {any} attributes\n * @param {Array.<string|any>} [children]\n * @returns {any}\n *\n * @typedef Context\n * @property {html|svg} schema\n * @property {string|null} prefix\n * @property {number} key\n * @property {boolean} react\n * @property {boolean} vue\n * @property {boolean} vdom\n * @property {boolean} hyperscript\n *\n * @typedef Options\n * @property {string|null} [prefix]\n * @property {'html'|'svg'} [space]\n */\nimport { html, svg, find, hastToReact } from 'property-information';\nimport { stringify as spaces } from 'space-separated-tokens';\nimport { stringify as commas } from 'comma-separated-tokens';\nimport style from 'style-to-object';\nimport { webNamespaces } from 'web-namespaces';\nimport { convert } from 'unist-util-is';\nconst ns =\n/** @type {Record<string, string>} */\nwebNamespaces;\nconst toReact =\n/** @type {Record<string, string>} */\nhastToReact;\nconst own = {}.hasOwnProperty;\n/** @type {AssertRoot} */\n// @ts-expect-error it’s correct.\n\nconst root = convert('root');\n/** @type {AssertElement} */\n// @ts-expect-error it’s correct.\n\nconst element = convert('element');\n/** @type {AssertText} */\n// @ts-expect-error it’s correct.\n\nconst text = convert('text');\n/**\n * @template {CreateElementLike} H\n * @param {H} h\n * @param {Element|Root} tree\n * @param {string|boolean|Options} [options]\n * @returns {ReturnType<H>}\n */\n\nexport function toH(h, tree, options) {\n  if (typeof h !== 'function') {\n    throw new TypeError('h is not a function');\n  }\n\n  const r = react(h);\n  const v = vue(h);\n  const vd = vdom(h);\n  /** @type {string|boolean|null|undefined} */\n\n  let prefix;\n  /** @type {Element} */\n\n  let node;\n\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    prefix = options;\n    options = {};\n  } else {\n    if (!options) options = {};\n    prefix = options.prefix;\n  }\n\n  if (root(tree)) {\n    // @ts-expect-error Allow `doctypes` in there, we’ll filter them out later.\n    node = tree.children.length === 1 && element(tree.children[0]) ? tree.children[0] : {\n      type: 'element',\n      tagName: 'div',\n      properties: {},\n      children: tree.children\n    };\n  } else if (element(tree)) {\n    node = tree;\n  } else {\n    throw new Error( // @ts-expect-error runtime.\n    'Expected root or element, not `' + (tree && tree.type || tree) + '`');\n  }\n\n  return transform(h, node, {\n    schema: options.space === 'svg' ? svg : html,\n    prefix: prefix === undefined || prefix === null ? r || v || vd ? 'h-' : null : typeof prefix === 'string' ? prefix : prefix ? 'h-' : null,\n    key: 0,\n    react: r,\n    vue: v,\n    vdom: vd,\n    hyperscript: hyperscript(h)\n  });\n}\n/**\n * Transform a hast node through a hyperscript interface to *anything*!\n *\n * @template {CreateElementLike} H\n * @param {H} h\n * @param {Element} node\n * @param {Context} ctx\n */\n\nfunction transform(h, node, ctx) {\n  const parentSchema = ctx.schema;\n  let schema = parentSchema;\n  let name = node.tagName;\n  /** @type {Record<string, unknown>} */\n\n  const attributes = {};\n  /** @type {Array.<ReturnType<H>|string>} */\n\n  const nodes = [];\n  let index = -1;\n  /** @type {string} */\n\n  let key;\n\n  if (parentSchema.space === 'html' && name.toLowerCase() === 'svg') {\n    schema = svg;\n    ctx.schema = schema;\n  }\n\n  for (key in node.properties) {\n    if (node.properties && own.call(node.properties, key)) {\n      addAttribute(attributes, key, node.properties[key], ctx, name);\n    }\n  }\n\n  if (ctx.vdom) {\n    if (schema.space === 'html') {\n      name = name.toUpperCase();\n    } else if (schema.space) {\n      attributes.namespace = ns[schema.space];\n    }\n  }\n\n  if (ctx.prefix) {\n    ctx.key++;\n    attributes.key = ctx.prefix + ctx.key;\n  }\n\n  if (node.children) {\n    while (++index < node.children.length) {\n      const value = node.children[index];\n\n      if (element(value)) {\n        nodes.push(transform(h, value, ctx));\n      } else if (text(value)) {\n        nodes.push(value.value);\n      }\n    }\n  } // Restore parent schema.\n\n\n  ctx.schema = parentSchema; // Ensure no React warnings are triggered for void elements having children\n  // passed in.\n\n  return nodes.length > 0 ? h.call(node, name, attributes, nodes) : h.call(node, name, attributes);\n}\n/**\n * @param {Record<string, unknown>} props\n * @param {string} prop\n * @param {unknown} value\n * @param {Context} ctx\n * @param {string} name\n */\n// eslint-disable-next-line complexity, max-params\n\n\nfunction addAttribute(props, prop, value, ctx, name) {\n  const info = find(ctx.schema, prop);\n  /** @type {string|undefined} */\n\n  let subprop; // Ignore nullish and `NaN` values.\n  // Ignore `false` and falsey known booleans for hyperlike DSLs.\n\n  if (value === undefined || value === null || typeof value === 'number' && Number.isNaN(value) || value === false && (ctx.vue || ctx.vdom || ctx.hyperscript) || !value && info.boolean && (ctx.vue || ctx.vdom || ctx.hyperscript)) {\n    return;\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value);\n  } // Treat `true` and truthy known booleans.\n\n\n  if (info.boolean && ctx.hyperscript) {\n    value = '';\n  } // VDOM, Vue, and React accept `style` as object.\n\n\n  if (info.property === 'style' && typeof value === 'string' && (ctx.react || ctx.vue || ctx.vdom)) {\n    value = parseStyle(value, name);\n  }\n\n  if (ctx.vue) {\n    if (info.property !== 'style') subprop = 'attrs';\n  } else if (!info.mustUseProperty) {\n    if (ctx.vdom) {\n      if (info.property !== 'style') subprop = 'attributes';\n    } else if (ctx.hyperscript) {\n      subprop = 'attrs';\n    }\n  }\n\n  if (subprop) {\n    props[subprop] = Object.assign(props[subprop] || {}, {\n      [info.attribute]: value\n    });\n  } else if (info.space && ctx.react) {\n    props[toReact[info.property] || info.property] = value;\n  } else {\n    props[info.attribute] = value;\n  }\n}\n/**\n * Check if `h` is `react.createElement`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\n\n\nfunction react(h) {\n  /** @type {unknown} */\n  const node = h('div', {});\n  return Boolean(node && ( // @ts-expect-error Looks like a React node.\n  '_owner' in node || '_store' in node) && ( // @ts-expect-error Looks like a React node.\n  node.key === undefined || node.key === null));\n}\n/**\n * Check if `h` is `hyperscript`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\n\n\nfunction hyperscript(h) {\n  return 'context' in h && 'cleanup' in h;\n}\n/**\n * Check if `h` is `virtual-dom/h`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\n\n\nfunction vdom(h) {\n  /** @type {unknown} */\n  const node = h('div', {}); // @ts-expect-error Looks like a vnode.\n\n  return node.type === 'VirtualNode';\n}\n/**\n * Check if `h` is Vue.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\n\n\nfunction vue(h) {\n  /** @type {unknown} */\n  const node = h('div', {}); // @ts-expect-error Looks like a Vue node.\n\n  return Boolean(node && node.context && node.context._isVue);\n}\n/**\n * @param {string} value\n * @param {string} tagName\n * @returns {Record<string, string>}\n */\n\n\nfunction parseStyle(value, tagName) {\n  /** @type {Record<string, string>} */\n  const result = {};\n\n  try {\n    style(value, (name, value) => {\n      if (name.slice(0, 4) === '-ms-') name = 'ms-' + name.slice(4);\n      result[name.replace(/-([a-z])/g,\n      /**\n       * @param {string} _\n       * @param {string} $1\n       * @returns {string}\n       */\n      (_, $1) => $1.toUpperCase())] = value;\n    });\n  } catch (error) {\n    error.message = tagName + '[style]' + error.message.slice('undefined'.length);\n    throw error;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/bian/Desktop/CS/a/client/node_modules/hast-to-hyperscript/index.js"],"names":["html","svg","find","hastToReact","stringify","spaces","commas","style","webNamespaces","convert","ns","toReact","own","hasOwnProperty","root","element","text","toH","h","tree","options","TypeError","r","react","v","vue","vd","vdom","prefix","node","children","length","type","tagName","properties","Error","transform","schema","space","undefined","key","hyperscript","ctx","parentSchema","name","attributes","nodes","index","toLowerCase","call","addAttribute","toUpperCase","namespace","value","push","props","prop","info","subprop","Number","isNaN","boolean","Array","isArray","commaSeparated","property","parseStyle","mustUseProperty","Object","assign","attribute","Boolean","context","_isVue","result","slice","replace","_","$1","error","message"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('unist-util-is').AssertPredicate<Element>} AssertElement\n * @typedef {import('unist-util-is').AssertPredicate<Text>} AssertText\n * @typedef {import('unist-util-is').AssertPredicate<Root>} AssertRoot\n *\n * @callback CreateElementLike\n * @param {string} name\n * @param {any} attributes\n * @param {Array.<string|any>} [children]\n * @returns {any}\n *\n * @typedef Context\n * @property {html|svg} schema\n * @property {string|null} prefix\n * @property {number} key\n * @property {boolean} react\n * @property {boolean} vue\n * @property {boolean} vdom\n * @property {boolean} hyperscript\n *\n * @typedef Options\n * @property {string|null} [prefix]\n * @property {'html'|'svg'} [space]\n */\n\nimport {html, svg, find, hastToReact} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {stringify as commas} from 'comma-separated-tokens'\nimport style from 'style-to-object'\nimport {webNamespaces} from 'web-namespaces'\nimport {convert} from 'unist-util-is'\n\nconst ns = /** @type {Record<string, string>} */ (webNamespaces)\nconst toReact = /** @type {Record<string, string>} */ (hastToReact)\n\nconst own = {}.hasOwnProperty\n\n/** @type {AssertRoot} */\n// @ts-expect-error it’s correct.\nconst root = convert('root')\n/** @type {AssertElement} */\n// @ts-expect-error it’s correct.\nconst element = convert('element')\n/** @type {AssertText} */\n// @ts-expect-error it’s correct.\nconst text = convert('text')\n\n/**\n * @template {CreateElementLike} H\n * @param {H} h\n * @param {Element|Root} tree\n * @param {string|boolean|Options} [options]\n * @returns {ReturnType<H>}\n */\nexport function toH(h, tree, options) {\n  if (typeof h !== 'function') {\n    throw new TypeError('h is not a function')\n  }\n\n  const r = react(h)\n  const v = vue(h)\n  const vd = vdom(h)\n  /** @type {string|boolean|null|undefined} */\n  let prefix\n  /** @type {Element} */\n  let node\n\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    prefix = options\n    options = {}\n  } else {\n    if (!options) options = {}\n    prefix = options.prefix\n  }\n\n  if (root(tree)) {\n    // @ts-expect-error Allow `doctypes` in there, we’ll filter them out later.\n    node =\n      tree.children.length === 1 && element(tree.children[0])\n        ? tree.children[0]\n        : {\n            type: 'element',\n            tagName: 'div',\n            properties: {},\n            children: tree.children\n          }\n  } else if (element(tree)) {\n    node = tree\n  } else {\n    throw new Error(\n      // @ts-expect-error runtime.\n      'Expected root or element, not `' + ((tree && tree.type) || tree) + '`'\n    )\n  }\n\n  return transform(h, node, {\n    schema: options.space === 'svg' ? svg : html,\n    prefix:\n      prefix === undefined || prefix === null\n        ? r || v || vd\n          ? 'h-'\n          : null\n        : typeof prefix === 'string'\n        ? prefix\n        : prefix\n        ? 'h-'\n        : null,\n    key: 0,\n    react: r,\n    vue: v,\n    vdom: vd,\n    hyperscript: hyperscript(h)\n  })\n}\n\n/**\n * Transform a hast node through a hyperscript interface to *anything*!\n *\n * @template {CreateElementLike} H\n * @param {H} h\n * @param {Element} node\n * @param {Context} ctx\n */\nfunction transform(h, node, ctx) {\n  const parentSchema = ctx.schema\n  let schema = parentSchema\n  let name = node.tagName\n  /** @type {Record<string, unknown>} */\n  const attributes = {}\n  /** @type {Array.<ReturnType<H>|string>} */\n  const nodes = []\n  let index = -1\n  /** @type {string} */\n  let key\n\n  if (parentSchema.space === 'html' && name.toLowerCase() === 'svg') {\n    schema = svg\n    ctx.schema = schema\n  }\n\n  for (key in node.properties) {\n    if (node.properties && own.call(node.properties, key)) {\n      addAttribute(attributes, key, node.properties[key], ctx, name)\n    }\n  }\n\n  if (ctx.vdom) {\n    if (schema.space === 'html') {\n      name = name.toUpperCase()\n    } else if (schema.space) {\n      attributes.namespace = ns[schema.space]\n    }\n  }\n\n  if (ctx.prefix) {\n    ctx.key++\n    attributes.key = ctx.prefix + ctx.key\n  }\n\n  if (node.children) {\n    while (++index < node.children.length) {\n      const value = node.children[index]\n\n      if (element(value)) {\n        nodes.push(transform(h, value, ctx))\n      } else if (text(value)) {\n        nodes.push(value.value)\n      }\n    }\n  }\n\n  // Restore parent schema.\n  ctx.schema = parentSchema\n\n  // Ensure no React warnings are triggered for void elements having children\n  // passed in.\n  return nodes.length > 0\n    ? h.call(node, name, attributes, nodes)\n    : h.call(node, name, attributes)\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string} prop\n * @param {unknown} value\n * @param {Context} ctx\n * @param {string} name\n */\n// eslint-disable-next-line complexity, max-params\nfunction addAttribute(props, prop, value, ctx, name) {\n  const info = find(ctx.schema, prop)\n  /** @type {string|undefined} */\n  let subprop\n\n  // Ignore nullish and `NaN` values.\n  // Ignore `false` and falsey known booleans for hyperlike DSLs.\n  if (\n    value === undefined ||\n    value === null ||\n    (typeof value === 'number' && Number.isNaN(value)) ||\n    (value === false && (ctx.vue || ctx.vdom || ctx.hyperscript)) ||\n    (!value && info.boolean && (ctx.vue || ctx.vdom || ctx.hyperscript))\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  // Treat `true` and truthy known booleans.\n  if (info.boolean && ctx.hyperscript) {\n    value = ''\n  }\n\n  // VDOM, Vue, and React accept `style` as object.\n  if (\n    info.property === 'style' &&\n    typeof value === 'string' &&\n    (ctx.react || ctx.vue || ctx.vdom)\n  ) {\n    value = parseStyle(value, name)\n  }\n\n  if (ctx.vue) {\n    if (info.property !== 'style') subprop = 'attrs'\n  } else if (!info.mustUseProperty) {\n    if (ctx.vdom) {\n      if (info.property !== 'style') subprop = 'attributes'\n    } else if (ctx.hyperscript) {\n      subprop = 'attrs'\n    }\n  }\n\n  if (subprop) {\n    props[subprop] = Object.assign(props[subprop] || {}, {\n      [info.attribute]: value\n    })\n  } else if (info.space && ctx.react) {\n    props[toReact[info.property] || info.property] = value\n  } else {\n    props[info.attribute] = value\n  }\n}\n\n/**\n * Check if `h` is `react.createElement`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction react(h) {\n  /** @type {unknown} */\n  const node = h('div', {})\n  return Boolean(\n    node &&\n      // @ts-expect-error Looks like a React node.\n      ('_owner' in node || '_store' in node) &&\n      // @ts-expect-error Looks like a React node.\n      (node.key === undefined || node.key === null)\n  )\n}\n\n/**\n * Check if `h` is `hyperscript`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction hyperscript(h) {\n  return 'context' in h && 'cleanup' in h\n}\n\n/**\n * Check if `h` is `virtual-dom/h`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction vdom(h) {\n  /** @type {unknown} */\n  const node = h('div', {})\n  // @ts-expect-error Looks like a vnode.\n  return node.type === 'VirtualNode'\n}\n\n/**\n * Check if `h` is Vue.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction vue(h) {\n  /** @type {unknown} */\n  const node = h('div', {})\n  // @ts-expect-error Looks like a Vue node.\n  return Boolean(node && node.context && node.context._isVue)\n}\n\n/**\n * @param {string} value\n * @param {string} tagName\n * @returns {Record<string, string>}\n */\nfunction parseStyle(value, tagName) {\n  /** @type {Record<string, string>} */\n  const result = {}\n\n  try {\n    style(value, (name, value) => {\n      if (name.slice(0, 4) === '-ms-') name = 'ms-' + name.slice(4)\n\n      result[\n        name.replace(\n          /-([a-z])/g,\n          /**\n           * @param {string} _\n           * @param {string} $1\n           * @returns {string}\n           */ (_, $1) => $1.toUpperCase()\n        )\n      ] = value\n    })\n  } catch (error) {\n    error.message =\n      tagName + '[style]' + error.message.slice('undefined'.length)\n    throw error\n  }\n\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}