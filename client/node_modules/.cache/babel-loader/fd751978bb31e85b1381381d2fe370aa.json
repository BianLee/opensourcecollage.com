{"ast":null,"code":"/**\n * @typedef {import('parse5').Node} P5Node\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {import('parse5').DocumentType} P5Doctype\n * @typedef {import('parse5').CommentNode} P5Comment\n * @typedef {import('parse5').TextNode} P5Text\n * @typedef {import('parse5').Element} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {import('parse5').ParentNode} P5Parent\n * @typedef {Exclude<P5Node, P5Document|P5Fragment>} P5Child\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('property-information').Info} Info\n * @typedef {'html'|'svg'} Space\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {Parent['children'][number]} Child\n * @typedef {Child|Root} Node\n *\n * @callback Handle\n * @param {Node} node\n * @param {Schema} schema\n * @returns {P5Node}\n */\nimport { html, svg, find } from 'property-information';\nimport { toH } from 'hast-to-hyperscript';\nimport { webNamespaces } from 'web-namespaces';\nimport { zwitch } from 'zwitch';\nvar own = {}.hasOwnProperty;\nvar one = zwitch('type', {\n  handlers: {\n    root,\n    element,\n    text,\n    comment,\n    doctype\n  }\n});\n/**\n * Transform a tree from hast to Parse5â€™s AST.\n *\n * @param {Node} tree\n * @param {Space} [space='html']\n * @returns {P5Node}\n */\n\nexport function toParse5(tree, space) {\n  // @ts-ignore Types are wrong.\n  return one(tree, space === 'svg' ? svg : html);\n}\n/**\n * @type {Handle}\n * @param {Root} node\n * @returns {P5Document}\n */\n\nfunction root(node, schema) {\n  /** @type {P5Document} */\n  var p5 = {\n    nodeName: '#document',\n    mode: (node.data || {}).quirksMode ? 'quirks' : 'no-quirks',\n    childNodes: []\n  }; // @ts-ignore Assume correct children.\n\n  p5.childNodes = all(node.children, p5, schema);\n  return patch(node, p5);\n}\n/**\n * @type {Handle}\n * @param {Root} node\n * @returns {P5Fragment}\n */\n\n\nfunction fragment(node, schema) {\n  /** @type {P5Fragment} */\n  var p5 = {\n    nodeName: '#document-fragment',\n    childNodes: []\n  }; // @ts-ignore Assume correct children.\n\n  p5.childNodes = all(node.children, p5, schema);\n  return patch(node, p5);\n}\n/**\n * @type {Handle}\n * @param {Doctype} node\n * @returns {P5Doctype}\n */\n\n\nfunction doctype(node) {\n  return patch(node, {\n    nodeName: '#documentType',\n    name: 'html',\n    publicId: '',\n    systemId: '',\n    parentNode: undefined\n  });\n}\n/**\n * @type {Handle}\n * @param {Text} node\n * @returns {P5Text}\n */\n\n\nfunction text(node) {\n  return patch(node, {\n    nodeName: '#text',\n    value: node.value,\n    parentNode: undefined\n  });\n}\n/**\n * @type {Handle}\n * @param {Comment} node\n * @returns {P5Comment}\n */\n\n\nfunction comment(node) {\n  return patch(node, {\n    nodeName: '#comment',\n    data: node.value,\n    parentNode: undefined\n  });\n}\n/**\n * @type {Handle}\n * @param {Element} node\n * @returns {P5Element}\n */\n\n\nfunction element(node, schema) {\n  /** @type {Space} */\n  // @ts-ignore Assume space.\n  var space = schema.space;\n  return toH(h, Object.assign({}, node, {\n    children: []\n  }), {\n    space\n  });\n  /**\n   * @param {string} name\n   * @param {Object.<string, string|boolean|number>} attrs\n   */\n\n  function h(name, attrs) {\n    /** @type {Array.<P5Attribute>} */\n    var values = [];\n    /** @type {Info} */\n\n    var info;\n    /** @type {P5Attribute} */\n\n    var value;\n    /** @type {string} */\n\n    var key;\n    /** @type {number} */\n\n    var index;\n    /** @type {P5Element} */\n\n    var p5;\n\n    for (key in attrs) {\n      if (!own.call(attrs, key) || attrs[key] === false) {\n        continue;\n      }\n\n      info = find(schema, key);\n\n      if (info.boolean && !attrs[key]) {\n        continue;\n      }\n\n      value = {\n        name: key,\n        value: attrs[key] === true ? '' : String(attrs[key])\n      };\n\n      if (info.space && info.space !== 'html' && info.space !== 'svg') {\n        index = key.indexOf(':');\n\n        if (index < 0) {\n          value.prefix = '';\n        } else {\n          value.name = key.slice(index + 1);\n          value.prefix = key.slice(0, index);\n        }\n\n        value.namespace = webNamespaces[info.space];\n      }\n\n      values.push(value);\n    }\n\n    if (schema.space === 'html' && node.tagName === 'svg') schema = svg;\n    p5 = patch(node, {\n      nodeName: name,\n      tagName: name,\n      attrs: values,\n      namespaceURI: webNamespaces[schema.space],\n      childNodes: [],\n      parentNode: undefined\n    }); // @ts-ignore Assume correct children.\n\n    p5.childNodes = all(node.children, p5, schema); // @ts-ignore Types are wrong.\n\n    if (name === 'template') p5.content = fragment(node.content, schema);\n    return p5;\n  }\n}\n/**\n * @param {Array.<Child>} children\n * @param {P5Parent} p5\n * @param {Schema} schema\n * @returns {Array.<P5Child>}\n */\n\n\nfunction all(children, p5, schema) {\n  var index = -1;\n  /** @type {Array.<P5Child>} */\n\n  var result = [];\n  /** @type {P5Child} */\n\n  var child;\n\n  if (children) {\n    while (++index < children.length) {\n      // @ts-ignore Assume child.\n      child = one(children[index], schema); // @ts-ignore types are wrong.\n\n      child.parentNode = p5;\n      result.push(child);\n    }\n  }\n\n  return result;\n}\n/**\n * Patch specific properties.\n *\n * @template {P5Node} T\n * @param {Node} node\n * @param {T} p5\n * @returns {T}\n */\n\n\nfunction patch(node, p5) {\n  var position = node.position;\n\n  if (position && position.start && position.end) {\n    // @ts-ignore Types are wrong.\n    p5.sourceCodeLocation = {\n      startLine: position.start.line,\n      startCol: position.start.column,\n      startOffset: position.start.offset,\n      endLine: position.end.line,\n      endCol: position.end.column,\n      endOffset: position.end.offset\n    };\n  }\n\n  return p5;\n}","map":{"version":3,"sources":["/home/bian/Desktop/Summer/a/client/node_modules/hast-util-to-parse5/lib/index.js"],"names":["html","svg","find","toH","webNamespaces","zwitch","own","hasOwnProperty","one","handlers","root","element","text","comment","doctype","toParse5","tree","space","node","schema","p5","nodeName","mode","data","quirksMode","childNodes","all","children","patch","fragment","name","publicId","systemId","parentNode","undefined","value","h","Object","assign","attrs","values","info","key","index","call","boolean","String","indexOf","prefix","slice","namespace","push","tagName","namespaceURI","content","result","child","length","position","start","end","sourceCodeLocation","startLine","line","startCol","column","startOffset","offset","endLine","endCol","endOffset"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('parse5').Node} P5Node\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {import('parse5').DocumentType} P5Doctype\n * @typedef {import('parse5').CommentNode} P5Comment\n * @typedef {import('parse5').TextNode} P5Text\n * @typedef {import('parse5').Element} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {import('parse5').ParentNode} P5Parent\n * @typedef {Exclude<P5Node, P5Document|P5Fragment>} P5Child\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('property-information').Info} Info\n * @typedef {'html'|'svg'} Space\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {Parent['children'][number]} Child\n * @typedef {Child|Root} Node\n *\n * @callback Handle\n * @param {Node} node\n * @param {Schema} schema\n * @returns {P5Node}\n */\n\nimport {html, svg, find} from 'property-information'\nimport {toH} from 'hast-to-hyperscript'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\nvar own = {}.hasOwnProperty\n\nvar one = zwitch('type', {handlers: {root, element, text, comment, doctype}})\n\n/**\n * Transform a tree from hast to Parse5â€™s AST.\n *\n * @param {Node} tree\n * @param {Space} [space='html']\n * @returns {P5Node}\n */\nexport function toParse5(tree, space) {\n  // @ts-ignore Types are wrong.\n  return one(tree, space === 'svg' ? svg : html)\n}\n\n/**\n * @type {Handle}\n * @param {Root} node\n * @returns {P5Document}\n */\nfunction root(node, schema) {\n  /** @type {P5Document} */\n  var p5 = {\n    nodeName: '#document',\n    mode: (node.data || {}).quirksMode ? 'quirks' : 'no-quirks',\n    childNodes: []\n  }\n  // @ts-ignore Assume correct children.\n  p5.childNodes = all(node.children, p5, schema)\n  return patch(node, p5)\n}\n\n/**\n * @type {Handle}\n * @param {Root} node\n * @returns {P5Fragment}\n */\nfunction fragment(node, schema) {\n  /** @type {P5Fragment} */\n  var p5 = {nodeName: '#document-fragment', childNodes: []}\n  // @ts-ignore Assume correct children.\n  p5.childNodes = all(node.children, p5, schema)\n  return patch(node, p5)\n}\n\n/**\n * @type {Handle}\n * @param {Doctype} node\n * @returns {P5Doctype}\n */\nfunction doctype(node) {\n  return patch(node, {\n    nodeName: '#documentType',\n    name: 'html',\n    publicId: '',\n    systemId: '',\n    parentNode: undefined\n  })\n}\n\n/**\n * @type {Handle}\n * @param {Text} node\n * @returns {P5Text}\n */\nfunction text(node) {\n  return patch(node, {\n    nodeName: '#text',\n    value: node.value,\n    parentNode: undefined\n  })\n}\n\n/**\n * @type {Handle}\n * @param {Comment} node\n * @returns {P5Comment}\n */\nfunction comment(node) {\n  return patch(node, {\n    nodeName: '#comment',\n    data: node.value,\n    parentNode: undefined\n  })\n}\n\n/**\n * @type {Handle}\n * @param {Element} node\n * @returns {P5Element}\n */\nfunction element(node, schema) {\n  /** @type {Space} */\n  // @ts-ignore Assume space.\n  var space = schema.space\n  return toH(h, Object.assign({}, node, {children: []}), {space})\n\n  /**\n   * @param {string} name\n   * @param {Object.<string, string|boolean|number>} attrs\n   */\n  function h(name, attrs) {\n    /** @type {Array.<P5Attribute>} */\n    var values = []\n    /** @type {Info} */\n    var info\n    /** @type {P5Attribute} */\n    var value\n    /** @type {string} */\n    var key\n    /** @type {number} */\n    var index\n    /** @type {P5Element} */\n    var p5\n\n    for (key in attrs) {\n      if (!own.call(attrs, key) || attrs[key] === false) {\n        continue\n      }\n\n      info = find(schema, key)\n\n      if (info.boolean && !attrs[key]) {\n        continue\n      }\n\n      value = {name: key, value: attrs[key] === true ? '' : String(attrs[key])}\n\n      if (info.space && info.space !== 'html' && info.space !== 'svg') {\n        index = key.indexOf(':')\n\n        if (index < 0) {\n          value.prefix = ''\n        } else {\n          value.name = key.slice(index + 1)\n          value.prefix = key.slice(0, index)\n        }\n\n        value.namespace = webNamespaces[info.space]\n      }\n\n      values.push(value)\n    }\n\n    if (schema.space === 'html' && node.tagName === 'svg') schema = svg\n\n    p5 = patch(node, {\n      nodeName: name,\n      tagName: name,\n      attrs: values,\n      namespaceURI: webNamespaces[schema.space],\n      childNodes: [],\n      parentNode: undefined\n    })\n\n    // @ts-ignore Assume correct children.\n    p5.childNodes = all(node.children, p5, schema)\n\n    // @ts-ignore Types are wrong.\n    if (name === 'template') p5.content = fragment(node.content, schema)\n\n    return p5\n  }\n}\n\n/**\n * @param {Array.<Child>} children\n * @param {P5Parent} p5\n * @param {Schema} schema\n * @returns {Array.<P5Child>}\n */\nfunction all(children, p5, schema) {\n  var index = -1\n  /** @type {Array.<P5Child>} */\n  var result = []\n  /** @type {P5Child} */\n  var child\n\n  if (children) {\n    while (++index < children.length) {\n      // @ts-ignore Assume child.\n      child = one(children[index], schema)\n\n      // @ts-ignore types are wrong.\n      child.parentNode = p5\n\n      result.push(child)\n    }\n  }\n\n  return result\n}\n\n/**\n * Patch specific properties.\n *\n * @template {P5Node} T\n * @param {Node} node\n * @param {T} p5\n * @returns {T}\n */\nfunction patch(node, p5) {\n  var position = node.position\n\n  if (position && position.start && position.end) {\n    // @ts-ignore Types are wrong.\n    p5.sourceCodeLocation = {\n      startLine: position.start.line,\n      startCol: position.start.column,\n      startOffset: position.start.offset,\n      endLine: position.end.line,\n      endCol: position.end.column,\n      endOffset: position.end.offset\n    }\n  }\n\n  return p5\n}\n"]},"metadata":{},"sourceType":"module"}